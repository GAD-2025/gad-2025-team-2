# 면접제안 및 상태관리 기능 구현에 필요한 데이터베이스 필드

## Application 테이블

현재 `applications` 테이블의 `status` 필드는 다음 값들을 지원합니다:

### 지원 상태 값
- `applied` (지원함) → 프론트엔드: `pending` (신규)
- `reviewed` (검토됨) → 프론트엔드: `reviewed` (진행중) - **면접 제안 후 자동 변경**
- `accepted` (합격) → 프론트엔드: `accepted` (면접결과 - 합격)
- `rejected` (불합격) → 프론트엔드: `rejected` (면접결과 - 불합격)
- `hold` (보류) → 프론트엔드: `hold` (면접결과 - 보류)

### 현재 테이블 구조
```sql
CREATE TABLE applications (
    applicationId VARCHAR(255) PRIMARY KEY,
    seekerId VARCHAR(255) NOT NULL COMMENT '구직자 User ID',
    jobId VARCHAR(255) NOT NULL COMMENT '공고 ID',
    status VARCHAR(50) DEFAULT 'applied' COMMENT '지원 상태: applied, reviewed, accepted, rejected, hold',
    appliedAt DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '지원 일시',
    updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정 일시',
    hiredAt DATETIME NULL COMMENT '채용 일시 (합격 시)',
    INDEX idx_seekerId (seekerId),
    INDEX idx_jobId (jobId),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

## 기능 흐름

### 1. 면접 제안 보내기
- **동작**: 고용주가 "면접 제안하기" 버튼 클릭
- **상태 변경**: `applied` → `reviewed`
- **API 호출**: `PATCH /applications/{application_id}` with `{ status: 'reviewed' }`
- **결과**: 지원자가 "진행중" 섹션으로 이동

### 2. 진행중 섹션에서 결과 처리
- **합격 버튼 클릭**: `reviewed` → `accepted`
  - 면접결과 섹션의 "합격" 필터로 자동 이동
- **보류 버튼 클릭**: `reviewed` → `hold`
  - 면접결과 섹션의 "보류" 필터로 자동 이동
- **불합격 버튼 클릭**: `reviewed` → `rejected`
  - 면접결과 섹션의 "불합격" 필터로 자동 이동

### 3. 보류 섹션에서 재처리
- **합격 버튼 클릭**: `hold` → `accepted`
  - 면접결과 섹션의 "합격" 필터로 자동 이동
- **불합격 버튼 클릭**: `hold` → `rejected`
  - 면접결과 섹션의 "불합격" 필터로 자동 이동

## 현재 구현 상태

### ✅ 이미 구현된 기능
1. `status` 필드에 모든 필요한 상태 값 지원 (`applied`, `reviewed`, `accepted`, `rejected`, `hold`)
2. `applicationsAPI.update()` 함수로 상태 업데이트 가능
3. 면접 제안 후 상태를 `reviewed`로 자동 업데이트
4. 진행중 섹션에서 합격/보류/불합격 버튼 표시
5. 버튼 클릭 시 상태 변경 및 필터 자동 이동

### 📝 추가 고려사항 (선택사항)

#### 면접 제안 데이터 저장 (현재는 localStorage 사용)
만약 면접 제안 데이터를 데이터베이스에 저장하려면:

```sql
-- 면접 제안 테이블 (선택사항)
CREATE TABLE interview_proposals (
    id VARCHAR(255) PRIMARY KEY,
    application_id VARCHAR(255) NOT NULL COMMENT '지원서 ID',
    employer_id VARCHAR(255) NOT NULL COMMENT '고용주 ID',
    selected_dates JSON COMMENT '선택된 날짜 배열',
    time_slots JSON COMMENT '시간 슬롯 정보',
    message TEXT COMMENT '면접 제안 메시지',
    status ENUM('pending', 'accepted', 'rejected', 'hold') DEFAULT 'pending' COMMENT '면접 제안 상태',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_application_id (application_id),
    INDEX idx_employer_id (employer_id),
    INDEX idx_status (status),
    FOREIGN KEY (application_id) REFERENCES applications(applicationId) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**참고**: 현재는 면접 제안 데이터를 `localStorage`에 저장하고 있으며, 이는 프로토타입 단계에서 충분합니다. 프로덕션 환경에서는 위의 테이블을 추가하는 것을 권장합니다.

## SQL 확인 쿼리

현재 `applications` 테이블의 상태 분포 확인:

```sql
USE team2_db;

-- 상태별 지원자 수 확인
SELECT 
    status,
    CASE 
        WHEN status = 'applied' THEN '신규'
        WHEN status = 'reviewed' THEN '진행중'
        WHEN status = 'accepted' THEN '합격'
        WHEN status = 'rejected' THEN '불합격'
        WHEN status = 'hold' THEN '보류'
        ELSE status
    END as status_kr,
    COUNT(*) as count
FROM applications
GROUP BY status
ORDER BY 
    CASE status
        WHEN 'applied' THEN 1
        WHEN 'reviewed' THEN 2
        WHEN 'accepted' THEN 3
        WHEN 'hold' THEN 4
        WHEN 'rejected' THEN 5
    END;
```

## 결론

**현재 `applications` 테이블의 `status` 필드만으로 모든 기능이 구현 가능합니다.**

추가로 필요한 필드는 없으며, 면접 제안 데이터를 데이터베이스에 저장하려는 경우에만 `interview_proposals` 테이블을 추가하면 됩니다.
